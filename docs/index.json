[
  {
    "content": "Git で起こるトラブル 基礎編と応用編を通して Git の操作にはある程度の自信がついたのではないのかなと思います。\n実際に開発プロジェクトでは基礎編と応用編の知識を活かすことで開発を進めることができるでしょう。\nしかし、実際の開発プロジェクトでは様々なトラブルが起きるのです。\nこの実践編ではよくあるトラブルを解消をする方法を学んでいきましょう。\n競合の解消 競合とは 変更内容をマージする際に、同じファイルの同じ行が既に変更されていると衝突してしまい「競合（コンフリクト）」と呼ばれる事象が発生します。\n競合が発生すると、２つの履歴のうちどちらの変更が正しいかは Git が判断することができないため同ファイルのマージが中断されます。\nマージの際に競合が発生すると以下のようなメッセージが表示されます。\nAuto-merging sample.txt CONFLICT (content): Merge conflict in sample.txt Automatic merge failed; fix conflicts and then commit the result. チーム開発をしていると競合が起きるのも珍しくありません。 そして、競合が起きるのは決して悪いことではありません。 大事なのは履歴のうちどちらの変更が正しいかの判断を間違えないことです。\n競合を解消してみよう 競合を解消すると開発者はつぎのいずれかの選択肢を取ることになります。\n マージを中止してマージ前の状態に戻す 競合を解消してマージをする  今回は両方とも試してみましょう。\n マージを中止してマージ前の状態に戻す\n その場で競合の解消が難しいなどの理由でどうしてもマージができない場合があります。\nそのようなときは、以下のコマンドで実行して git merge コマンドを中止することができます。\ngit merge --abort これは競合の解消ではなくマージを中断しただけのため、\n競合箇所を修正せずに再度マージをすると再び競合が発生します。\n 競合を解消してマージをする\n まずは競合を起こしているファイルを開きましょう。\n競合が起きている部分はハイライトされているためわかりやすくなっています。\n「«« HEAD」〜 「==========」が main ブランチにマージされている内容、\n「==========」〜 「»» develop2」が develop2 ブランチの内容となっています。\n今回は develop2 ブランチの内容を正しいということにしましょう。\nハイライトと main ブランチにマージされた内容を削除して、\ndevelop2 ブランチの内容だけを残すようにしましょう。\nインデックスにはまだマージ前のファイルが記録されているため、\n競合を解消したファイルを git add コマンドで再度インデックスに追加する必要があります。\n今回は以下のコマンドを実行して、 sample.txt をインデックスに追加しましょう。\ngit add sample.txt あとはコミットをするだけです。\nコンフリクトを解消したコミットはデフォルトでメッセージが生成されます。\nメッセージは付与せずに以下のコマンドを実行してみましょう。\ngit commit 競合が起きないように開発者ごとに編集できるファイルを限定させるという運用ルールを設けることもできますが、これではチーム全体の作業効率を下げてしまうことになります。\n慣れれば競合は恐いものではないので、ぜひ競合が起きた際は解消に挑戦してみましょう！\n",
    "description": "",
    "tags": null,
    "title": "競合の解消",
    "uri": "/git-education/practical/conflict/"
  },
  {
    "content": "基礎編をマスターすることができたのであれば、Git 管理をしながら開発することに自信を持つことができていると思います。\nしかし、チーム開発で Git を扱うにはまだ不十分です。\n例えば、次のような状態になったとき、あなたはどうしますか？\nあらまし 仮にチーム内で開発者とテスターが分かれていた場合でのお話です。 開発者AはテスターBにソースを渡すため、リモートリポジトリに変更を加えたソースを push しました。 ところが、テスターBが pull をしてテストをしたところバグが見つかりました。 そこで、テスターBは開発者Aにバグがあることを伝え、修正を依頼しました。 一見問題はなさそうですが、もし別の開発者Cがいた場合はどうでしょう？ 開発者Cももちろんリモートリポジトリから最新のソースを取得して開発をおこないます。 リモートリポジトリから取得したソースにバグがあった場合、開発者Cにも影響を与えてしまいます。 このようなときに ブランチ は活躍します。\nブランチの運用方法は様々ですが、今回はデフォルトの main ブランチの他に開発用のブランチ（ develop ブランチ）を作成する運用をすることで今回の問題は解消されます。 ここからはブランチについて学んでいきましょう。\n",
    "description": "",
    "tags": null,
    "title": "Git と チーム開発",
    "uri": "/git-education/advanced/team-development/"
  },
  {
    "content": "Chapter 1 基礎編 Git でバージョン管理をする上で最低限必要となる知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "基礎編",
    "uri": "/git-education/basics/"
  },
  {
    "content": "Git の基本 Git は開発現場では不可欠なバージョン管理システムのサービスです。\n本チャプターでは Git の基本を実際にコマンドを実行していきながら学んでいきます。\nまずは、バージョン管理システムの概要から理解していきましょう。\nバージョン管理システムとは ソースコードのようなファイルの変更履歴を管理するシステムを バージョン管理システム と呼びます。\nGit はこのバージョン管理システムに分類されます。\nファイルに対する追加・変更・削除の履歴を管理することで、過去の変更箇所を確認したり、任意のバージョンに戻すことができます。\nバージョン管理システムには 分散型 と 集中型 の２種類があります。\nGit は分散型に分類されるのですが、それぞれの違いについて確認していきましょう。\n集中型バージョン管理システム 集中型はリポジトリはリモート環境に１つのみ存在します。 チームメンバーは各自対象のファイルをリモート環境からローカル環境に取得して編集します。\n分散型バージョン管理システム リポジトリはリモート環境に１つだけではなく、各メンバーのローカル環境にも存在します。 各メンバーは自身のローカル環境のリポジトリに対して、ファイルの編集内容を記録していき、 最終的にはローカル環境のリポジトリとリモート環境のリポジトリを統合（マージ）します。\n分散型のメリット  自身の編集（コミット）が他のメンバーへ影響を与えない。 ⇨ 他のメンバーも同時に作業を進められるため作業効率を上げることができます。 ローカルリポジトリでテストをしてからリモートリポジトリで共有できる。 ⇨ リモートリポジトリに入れたのちにテストをしてバグが発生した場合、他のメンバーにも影響が生じてしまいます。  Git とは Git を触っていると以下のようなハッシュ値をよく見かけると思います。\n以下は後々登場する Git のコミットログです。\ncommit 5c670db6fc4a8d109a5e2724c421cd8105c2598f (HEAD -\u003e master) 実は Git により自身の編集（コミット）ごとに重複することのないハッシュ値が割り当てられています。 このハッシュ値はSHA-1ハッシュと呼ばれており、16進数の文字（0-9とa-f）で構成された40文字の文字列です。 ファイルの内容もしくは Git 内のディレクトリ構造を元に計算されます。\nこれは Git が内部でもっているデータベースの中で管理するために割り当てられているのです。\nそのため、Gitはこのファイルはいつどのように変更したのかという観点は意識しておらず、 この編集でどのファイルをどのように変更したのかという観点で管理をしています。\nGit のできること\n ファイルの変更履歴を管理できる ファイルを過去の状態に戻せる ファイルをチームで共有することできる  Git を始めてみよう Git の公式サイトからインストーラーをダウンロードすることができます。\n以下のURLからインスト＝ラーをダウンロードして Git をインストールしましょう。\nhttps://git-scm.com/downloads\nGit のインストールが完了しましたら、インストールが完了できているかを確認しましょう。\nターミナルを起動して、インストールされている Git のバージョンを確認するコマンドを実行しましょう。\n以下のコマンドを実行して、git version X.X.X (※) がターミナル上に表示されればインストールは完了できています！\n※Xの部分には数値が表示されます。\ngit --version ",
    "description": "",
    "tags": null,
    "title": "Git の基本",
    "uri": "/git-education/basics/git-basics/"
  },
  {
    "content": "コミットの比較 ファイルを更新すると、「意図した通りに更新できているかな？」や「意図していないところを更新していないかな？」とファイルの更新前後の差分を確認したくなるときがあると思います。\nこのようなときは git diff コマンドを使いましょう。\nこのコマンドは指定した2点間のファイルの差分を確認できます。\ngit diff DEMO\n今回は sample.txt の内容を「APPLE」から「ORANGE」に上書きして差分を確認してみましょう。 以下のコマンドで上書きと更新前後の差分の確認をしてみましょう。\necho ORANGE \u003e sample.txt git diff diff --git a/sample.txt b/sample.txt index e427984..fd0eebf 100644 --- a/sample.txt +++ b/sample.txt @@ -1 +1 @@ -HELLO +ORANGE +マークは追加された行で、-マークは削除された行を意味しています。\n上記の実行結果では -HELLO は HELLO が削除されたということ、 +ORANGE は ORANGE が追加されたことがわかります。\nまた、以下のコマンドで、現在はファイルと指定したコミットの差分を確認することができます。\ngit diff [コミットのハッシュ値] また、特定のコミット間の比較をすることもできます。\ngit diff [比較元のコミットのハッシュ値] [比較先のコミットのハッシュ値] ローカルリポジトリ内だけでなく、リモートブランチとも差分を比較することができます。\nこの場合はあらかじめ比較先のリモートブランチを git fetch コマンドで参照をダウンロードしておきましょう。\ngit fetch origin [リモートリポジトリのブランチ名] git diff [ローカルリポジトリのブランチ名] origin/[リモートリポジトリのブランチ名] ",
    "description": "",
    "tags": null,
    "title": "コミットの比較",
    "uri": "/git-education/practical/difference/"
  },
  {
    "content": "Chapter 2 応用編 Git でチーム開発をする上で必要となる知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "応用編",
    "uri": "/git-education/advanced/"
  },
  {
    "content": "ブランチとは 1つのプロジェクトから分岐させることにより、共有しているプロジェクトに影響を与えずに開発ができる機能です。\nブランチを切ることにより、同時並行で目的別に作業をすることができます。\n※ブランチを作ることを「ブランチを切る」と言います。\nGit は master ブランチがデフォルトになっており、実は初級編では master ブランチで作業をしていました。\n現在作業をしているブランチは以下のコマンドで確認をすることができます。\ngit branch git branch コマンドを実行すると、ローカルリポジトリ内のブランチ名の一覧を以下のように表示されます。 注意： Git のコミットログがない場合はブランチ名は表示されないので、git commit を実施した上でgit branchコマンドを実行しましょう。 現在作業しているブランチの左隣に*が表示されます。\nいまは master ブランチしかないため表示されるブランチ名を1つのみですが、\nブランチを増やすと現在作業していないブランチの名前もこのコマンドで確認することができます。\n* master 一般的な開発プロジェクトでは master ブランチの内容が納品物（テストが完了した最新のソースコード）となるため、\n機能の改修や追加する場合はこの master ブランチから開発用のブランチを切った上で作業を行います。\n注意： ローカルリポジトリと同様にリモートリポジトリ（GitHubなど）にもブランチが存在します。\nリモートリポジトリのブランチは git push コマンドを実行する際に生成されます。\nブランチを使ってみよう それでは開発用のブランチを作ってみましょう。 ブランチ名は自由につけることができますが、今回のブランチ名は develop にしましょう。\ngit branch コマンドの後ろに作成したいブランチの名前を指定すると同じ名前のブランチを作ることができます。\ngit branch develop 再度 git branch コマンドを実行すると以下のようにブランチの一覧が表示されます。\ndevelop ブランチが作成できているかを確認してみましょう。\n develop * master develop ブランチができていることが確認できたと思いますが、現在作業しているブランチを意味する*は master ブランチの左隣にあります。\nつまり、ブランチを作ることができたものの、作成したブランチ（develop）を作業ブランにすることができていません。\nまだ master ブランチが作業ブランチとなっている状態のため、作業ブランチを develop ブランチに切り替えてみましょう。\nブランチの切り替えは git checkout コマンドで行うことができます。\ngit checkout [切り替えたいブランチの名前] 注意：切り替えようとしたブランチがない場合はエラー（error: pathspec '存在しないブランチ名' did not match any file(s) known to git）が発生するので、git checkout コマンドを実行する前にあらかじめブランチを作っておきましょう。\n今回は develop ブランチに切り替えたいので、以下のコマンドを実行しましょう。\ngit checkout develop それでは再度 git branch コマンドで develop ブランチが作業ブランチになっているかを確認してみましょう。 develop の左隣に * があればブランチの切り替えに成功です！\n* develop master 続いて、切り替えた develop ブランチでファイルを編集をしてみましょう。\nmaster ブランチで作成した sample.txt には hello と書かれていますが、\nこれを develop ブランチでは HELLO に上書きをします。\necho HELLO \u003e sample.txt ファイルの上書きのコマンドを実行できましたら、cat コマンドでsample.txtが上書きできているかを確認しましょう。\ncat コマンドの実行結果が以下の通りであれば成功です。\nHELLO ではここで、git status コマンドでステータスを確認してみましょう。\nOn branch develop Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: sample.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") On branch develop は develop ブランチで作業していることを意味しています。\nChanges not staged for commit　は修正はしたもののまだ git add を実行していないため、\nコミットができないファイルをあるよという意味です。\nその下に modified: sample.txt と表示されていますが、これは sample.txt に変更が発生しているという意味になります。\nそれでは以下のコマンドを実行して、今回編集した sample.txt の変更内容を Git に登録してみましょう。 ブランチ名が変わってもこのフロー（ステージ済 → 修正済 → コミット済）は変わりません。\ngit add sample.txt git commit -m \"develop commit\" コミットが無事完了できたかをgit log コマンドで確認してみましょう。\nコミットのメッセージが develop commit となっているコミットログが残っていれば成功です！\ncommit 1be05c74b8ae9ce1f8b1a09510b1367c88e1100e (HEAD -\u003e develop) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 11:21:55 2022 +0900 develop commit commit 5db36ee820d446e27838869e79cbae3526f71a8f (master) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit ではここで、また master ブランチに戻ってみましょう。\nブランチの切り替える git checkout コマンドで master ブランチに戻ることができます。\ngit checkout master ここで再度 git log コマンドを実行してコミットログを確認してみましょう。\nすると、さきほど develop ブランチでコミットした develop commit がないことが確認できます。\ncommit 5db36ee820d446e27838869e79cbae3526f71a8f (HEAD -\u003e master) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit 念のため develop ブランチで編集した sample.txt の内容を cat コマンドで確認してみましょう。\n以下のように develop ブランチで変更を加える前の状態になっていることが確認できます。\nこれは develop ブランチの作業が main ブランチに影響を与えていないことを意味しています。\nhello このようにブランチを活用すると、他のブランチに影響を与えることなく作業することができます。\n",
    "description": "",
    "tags": null,
    "title": "Git のブランチ機能",
    "uri": "/git-education/advanced/branch/"
  },
  {
    "content": "Chapter 3 実践編 Git でトラブルが発生した際に解消する知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "実践編",
    "uri": "/git-education/practical/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/practical/summary/"
  },
  {
    "content": "マージとは さきほどはブランチを活用することで他のブランチに影響を与えることなく作業をすることができるとお伝えしました。\nしかし、作成したブランチはあくまで開発用ブランチなので、作業が完了したら納品物となる master ブランチにその変更内容を反映させる必要があります。 このようにあるブランチに他のブランチの変更内容を反映させる作業をマージ（統合）といいます。 マージは git merge コマンドで行うことできますが、変更履歴を更新したいブランチで実行する ことに注意してください。\ngit merge コマンドの後ろに変更内容を取得したいブランチ名を指定します。\ngit merge [変更内容を取得したいブランチ名] マージをしてみよう 今回は master ブランチに develop ブランチの変更内容を反映させてみましょう。\nまずは git branch コマンドを実行して、master ブランチが作業ブランチになっていることを確認しましょう。\n※ 今回は、変更履歴を更新したいブランチ = master ブランチです。\n develop * master 続いて以下の git merge コマンドを実行します。変更内容を取得したいブランチ名は develop を指定しましょう。\ngit merge develop 以下のようなメッセージが表示されればマージは成功です！\nUpdating 5db36ee..1be05c7 Fast-forward sample.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) それでは、マージ後の master ブランチの内容を確認してみましょう。\nまずは cat コマンドで sample.txt の中身を確認してみましょう。\n以下のように develop ブランチの内容に変わっていることが確認できます。\nHELLO 続いて、git log コマンドでコミットログを確認しましょう。\nmaster ブランチのコミットログに対して、develop ブランチでコミットログが追加されていることが 確認できます。\ncommit 1be05c74b8ae9ce1f8b1a09510b1367c88e1100e (HEAD -\u003e master, develop) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 11:21:55 2022 +0900 develop commit commit 5db36ee820d446e27838869e79cbae3526f71a8f Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit なお、マージ後もリポジトリ内には作業ブランチは残ります。\nそのため、マージ後に git checkout コマンドを実行することで同じ作業ブランチで作業を続けることができます。\nしかし、マージするとたいていの作業ブランチは不要になり、リポジトリ内に不要な作業ブランチが溜まっていくことになります。 このようなときは不要なブランチを削除するようにしましょう。 git branch コマンドのオプション（-d）を使用することでブランチを削除することができます。\ngit branch -d [削除したいブランチ名] 今回は develop ブランチを削除してみましょう。\ngit branch -d develop Deleted branch develop (was 1be05c7). 本当に develop ブランチを削除できているかを git branch コマンドで確認してみましょう。\n以下のように develop ブランチが表示されなければ成功です！\n* master このようにして作業用のブランチでの変更内容を他のブランチに反映させることができます。\nここではローカルリポジトリ内でのマージを行いましたが、実際の開発では以下のようなワークフローになります。\n リモートリポジトリの master ブランチから最新のソースを取得する。（git pull origin master） ローカルリポジトリで作業用ブランチを作成して、切り替える。（git branch XXX、git checkout XXX） 作業用ブランチでファイルを編集する。（git add、git commit） リモートリポジトリに作業用ブランチを作成して、アップロードする。（git push origin XXX） リモートリポジトリの作業用ブランチの内容を、リモートリポジトリの master ブランチにマージする。  最後の「リモートリポジトリの作業用ブランチの内容を、リモートリポジトリの master ブランチにマージする。」は、\nローカルリポジトリではなくリモートリポジトリで行うことができます。\nこれを次の GitHub のプルリクエスト機能 でご紹介します。\n",
    "description": "",
    "tags": null,
    "title": "Git のマージ機能",
    "uri": "/git-education/advanced/merge/"
  },
  {
    "content": "Git の基本コマンド Git は主にコマンドで操作を行います。\nここからは基本的な Git コマンドを紹介します。実際に Git コマンドを実行しながら確認をしていきましょう。\nGit コマンドを実行するにはまずローカル（皆さんのPC内）に Git で管理されているディレクトリを用意する必要があります。 Git で管理されているディレクトリを作成する方法は git init と git clone の２種類があります。\nそれぞれの違いを確認していきましょう。\n 既存ディレクトリを Git 管理する git init コマンドにより既に作成済みのディレクトリ（フォルダ）をローカルの Git リポジトリにすることができます。\n同コマンドを実行すると、指定したディレクトリに 「.git」 ディレクトリが作成されます。\nこの「.git」ディレクトリが配下にあるディレクトリは Git リポジトリとして扱われます。\ngit init [Gitリポジトリにしたいディレクトリのパス（省略可）] [Gitリポジトリにしたいディレクトリのパス]は省略することもでき、その場合はカレントディレクトリ（cdコマンド等で移動した現在のディレクトリ）が Git リポジトリとなります。\nDEMO 今回はデスクトップ上に git-tutorial ディレクトリを作成して、作成した同ディレクトリを Git リポジトリにしてみましょう。\ncd /Users/UserName/Desktop mkdir git-tutorial git init git-tutorial コマンド実行時に Initialized empty Git repository in /Users/UserName/Desktop/git-tutorial/.git/と表示されれば成功です。 ※上記のメッセージのうち、UserNameにはOSにログインしているユーザー名が表示されます。\ngit-tutorial フォルダを Git リポジトリにすることができたら、git-tutorial フォルダの配下に「.git」ディレクトリがあることを確認しましょう。\ncd git-tutorial ls -al  リモートリポジトリをクローンする GitHubなどに存在するリモートリポジトリをローカルにクローン（コピー）して開発を始めることもできます。\n実際の開発ではチームで１つのリポジトリを共有して利用するため、チームメンバーのひとりがリモートリポジトリを作成して、\n残りのメンバーはそのリポジトリをクローンするところから開発が始まることが一般的です。\nこれを実現するのが git clone コマンドで、コマンドの後ろにはクローンしたいリポジトリのURLを指定します。\ngit clone [リモートリポジトリのURL] [クローン先のディレクトリのパス（省略可）] [クローン先のディレクトリのパス（省略可）]は省略することもでき、\nその場合はカレントディレクトリ（cdコマンド等で移動した現在のディレクトリ）の配下にクローンした Git リポジトリが生成されます。\nDEMO 今回は GitHub 上にある git_tutorial リポジトリをローカルのデスクトップにクローンしてみましょう。\ncd /Users/UserName/Desktop git clone https://github.com/a-nakamura1015/git_tutorial.git コマンド実行御にデスクトップ上に git_tutorial リポジトリがあることを確認してみましょう。\n 既存ディレクトリにリモートリポジトリを追加する ローカルのリポジトリとリモートリポジトリを紐づけるコマンドもあるので紹介します。\ngit remote addコマンドでリモートリポジトリの名前（origin）とリモートリポジトリのURLを設定することで実現できます。\ngit remote add [リモートリポジトリの名前] [リモートリポジトリのURL] リモートリポジトリにはデフォルトでoriginという名前がついているので、この名前とリモートリポジトリのURLを紐付けるのが一般的です。\nまた、ローカルリポジトリが現在どのリモートリポジトリと紐づいているかは以下のコマンドで確認をすることができます。\ngit remote -v 一方で一度紐づけたリモートリポジトリとの紐付けを解除することもできます。\ngit remote rm [リモートリポジトリの名前] DEMO 今回はデスクトップ上に remote ディレクトリを作成して、git_tutorial リポジトリをリモートリポジトリとなるように設定してみましょう。 まずは以下のコマンドでデスクトップ上に remote ディレクトリを作成して、remote ディレクトリをカレントディレクトリにしましょう。\ncd /Users/UserName/Desktop mkdir remote cd remote 続いて、以下のコマンドでリモートリポジトリを紐付けましょう。\ngit remote add origin https://github.com/a-nakamura1015/git_tutorial.git 以下のコマンドで火もづいているリモートリポジトリを確認してみましょう。\ngit remote -v 以下のような結果が表示されれば成功です。\norigin\t/Users/UserName/Desktop/remote/ (fetch) origin\t/Users/UserName/Desktop/remote/ (push) 最後にリモートリポジトリとの紐付けを解除してみましょう。\n先ほどリモートリポジトリのURLを設定した際に指定したリモートリポジトリの名前は origin なので以下のコマンドを実行しましょう。\ngit remote rm origin これでリモートリポジトリの紐付けがなくなりました。試しにgit remote -vを実行してみても結果は何も表示されません。\nここまではディレクトリを Git リポジトリにするコマンドを紹介してきました。\nここからは本命のファイルの変更履歴を残す・確認するコマンドを紹介しますが、 「既存ディレクトリを Git 管理する」で作成した git-tutorial ディレクトリでコマンドの動作を確認していきます。\n以下のコマンドを実行した上で次に進みましょう。\ncd /Users/UserName/Desktop/git-tutorial  現在のステータスを確認する まずはGitリポジトリ内の状態を確認する git status コマンドを紹介します。\n後ほどファイルの状態をご紹介しますが、編集したファイルがどのような状態であるかを確認することができるコマンドです。\ngit status git-tutorial ディレクトリでこのコマンドを実行すると、以下の内容が表示されます。\nOn branch master No commits yet nothing to commit (create/copy files and use \"git add\" to track) On branch master はカレントブランチが master であることを意味します。（ブランチは応用編で解説します。） No commits yetはコミットがまだないことを意味します。\nコミットは Git が管理しているリポジトリ内のログに変更履歴を残す操作のことを指します。\nまだコミットをしていないので画面上にはNo commits yetと表示されています。\nこの後いくつかの Git コマンドを実行してステータスを変えていくので、その際にこのコマンドで状態を確認していきましょう。\n ファイルの状態の種類 ファイルの状態は３種類があり、ステージ済 → 修正済 → コミット済の順に推移していきます。 ファイルの変更履歴は Git で管理されていますが、ファイルを編集することで自動的に Git に残るわけではありません。\nこの３種類の状態を経て、Git に変更履歴を残すことができるのです。\n ステージ済：ファイルが編集された状態のこと。（git add コマンドを実行する前の状態） 修正済：ファイルがコミットの対象になっている状態のこと。（git commit コマンドを実行する前の状態） コミット済：Git にファイルの変更履歴が残っている状態のこと。   変更内容をインデックスに追加する 新規追加・変更したファイルは git add コマンドでステージ済の状態にすることができます。\nコマンドの後ろにはステージ済にしたいファイルのパスを指定します。\ngit add [編集したファイルのパス] DEMO 今回は sample.txt を新規で作成して、同ファイルをステージ済の状態にしてみましょう。 ①ファイルを新規で作成してみよう まずは以下のコマンドで sample.txt を作成します。\ntouch sample.txt 続いて、作成したファイルに hello を追記します。\necho hello \u003e sample.txt cat コマンドで sample.txt に hello が追記できているかを確認してみましょう。\ncat sample.txt ここで一旦ステータスを確認してみましょう。\ngit status git statusコマンドを実行すると以下の結果が表示されます。\nOn branch master No commits yet Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) sample.txt nothing added to commit but untracked files present (use \"git add\" to track) 着目する点は Untracked files です。\nこれはまだ Git の管理下に置かれていないファイルがあることを意味します。\nUntracked filesの後ろに sample.txt があるので、このファイルがまだ Git の管理下に置かれていないということです。\nGit の管理下に置かれるようにするには git add コマンドを実行する必要があります。\n②ファイルのステータスを修正済にする それでは、git add コマンドを実行してみましょう。\ngit add sample.txt git add コマンドを実行すると、以下の内容が表示されます。\nOn branch master No commits yet Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: sample.txt git add コマンドの実行前は Untracked files でしたが、実行後は Changes to be committed に変わりました。 これはファイルのステータスが修正済に変わり、コミットの対象になっていることを意味します。 今回は新しいファイルを Git に追加しようとしているため new file: sample.txtと表示されています。\n 変更内容をコミットする 先ほどは変更内容をインデックスに追加する（ステータスをステージ済 → 修正済にする）流れを確認しました。\n変更内容をインデックスに追加されていると、その変更内容を Git の履歴に残すことができるようになります。\nこの Git の履歴に残す操作を コミット といいますが、コミットは以下のコマンドで実行することができます。\ngit commit また、コミットの際に任意のメッセージを残すことができます。\n以下のコマンドのように、コマンドの後ろにオプション（-m）を指定して、その後に登録したいメッセージを入力します。\n（注意：メッセージはクォーテーションで囲う必要があります。）\n実際の開発プロジェクトでは「このコミットでどのような対応を行なったか」をメッセージに残すことになります。\nなぜなら、大量のコミットのログの中から特定のコミットを探す作業を用意にすることができ、 またチームメンバーにもどのような対応をしたのかを共有することもできるからです。\ngit commit -m \"message\" DEMO 今回は先ほど修正済（git add コマンドを実施済）となった sample.txt の新規追加する内容を Git の変更履歴に登録しましょう。\nコミットのメッセージにはfirst commit と入力しましょう。（今回のメッセージは英語でしたが、日本語を入力することも可能です。）\ngit commit -m \"first commit\" コマンドを実行すると以下のメッセージが画面に表示されます。\n[master (root-commit) 5c670db] first commit 1 file changed, 1 insertion(+) create mode 100644 sample.txt それでは、再度ステータスを確認してみましょう。\ngit status コマンドを実行すると以下のメッセージが画面に表示されます。\nOn branch master nothing to commit, working tree clean コミットを行なったことにより修正済のファイルがコミット済となったため、nothing to commit, working tree clean と表示されます。\n コミットログを確認する Git はコミットした履歴（コミットログ）を以下のコマンドで確認することができます。\ngit log コマンドを実行すると以下のようなログが表示されます。\ncommit 5c670db6fc4a8d109a5e2724c421cd8105c2598f (HEAD -\u003e master) Author: corgi9n \u003carapon@gmail.com\u003e Date: Fri Mar 11 03:44:55 2022 +0900 first commit commit 5c670db6fc4a8d109a5e2724c421cd8105c2598f (HEAD -\u003e master)のうち、 5c670db6fc4a8d109a5e2724c421cd8105c2598f はコミットのハッシュ値で、  (HEAD -\u003e master)は HEAD の内容を master ブランチに履歴を残したということを意味します。（ブランチについては応用編で解説します。） Authorは Git のコミットを残した Git アカウントが表示され、\nDateは Git のコミットを残した日時が表示されます。\nさらに下にはコミットの際に残したメッセージが表示されます。\nメモ：もし、git log コマンドを実行した後、表示されたログの下に : が表示されている場合は、 続けてコマンドを実行することができません。\nこの場合は q を入力して Enter キーを押すことで再度コマンドが実行できるようになります。\n 変更内容をリモートリポジトリに反映する 先ほどはコミットを完了して、ファイルの変更内容を無事コミットログに残すことができました。\nこれでやりたいことが終わったように感じますが、まだやらなければならないことが残っています。\nチーム開発している場合はリモートリポジトリでソースコードを共有しているため、\nファイルを編集した場合はリモートリポジトリにアップロードして、チームメンバーと共有できるようにする 必要があります。\n変更内容（コミットログ）をリモートリポジトリにアップロードするには、\ngit push コマンドを実行します。\ngit push origin [リモートリポジトリの名前] [リモートリポジトリのブランチ名] DEMO 今回は以下のコマンドを実行して、リモートリポジトリの main ブランチにアップロードをしてみましょう。\ngit push origin main コマンドを実行するとパスワードの入力を求められます。\nこれは GitHub アカウントに対して2段階認証を設定したため GitHub アカウントのパスワードを求められています。\nGitHub アカウントのパスワードを入力して Enter キーを押しましょう。\n(入力したパスワードは目視で確認ができないため、誤入力に気をつけましょう。)\n無事コマンドを完了できたら、GitHub上でアップロードされたファイルを確認してみましょう。\n リモートリポジトリから最新の履歴を取得する 先ほどは git push コマンドでリモートリポジトリに変更内容を反映いたしました。\nリモートリポジトリが更新されると、他のメンバーはリモートリポジトリから最新のソースコードをダウンロードすることになります。\n(もちろん、他のメンバーがリモートリポジトリを更新したら、あなたも最新のソースコードをダウンロードすることになります。) リモートリポジトリからソースコードをダウンロードする場合は、git pull コマンドを実行します。\ngit pull [リモートリポジトリの名前] [リモートリポジトリのブランチ名] DEMO 今回はリモートリポジトリ上に main ブランチしかないため、以下のコマンドを実行しましょう。\nただ今回はローカルリポジトリの内容をアップロードしたばかりのため、git pull コマンドを実行してもローカルリポジトリに変化はありません。\ngit pull origin main git pull コマンドを実行することでローカルリポジトリが変わる内容は、\n応用編で登場しますので楽しみにしてください！\n",
    "description": "",
    "tags": null,
    "title": "Git の基本コマンド",
    "uri": "/git-education/basics/git-command-basics/"
  },
  {
    "content": "GitHub とは ソフトウェア開発のプラットフォームであり、ソースコードを共有するためのホスティングサービス（サーバーの領域を貸し出すサービス）です。\n先述したリモートリポジトリはこのサービスが提供してくれます。\nGitHub のサーバー上にソースコードを格納することで、チームメンバーとソースコードを共有してコードレビューを行ったり、プロジェクトの管理を行ったりすることができます。\n使用用途も様々で、チームメンバーのみがアクセスできるようにすることもできれば、オープンソースとして提供するために世界中のエンジニアにアクセスしてもらえるようにすることもできます。\n名称に Git が含まれている通り、GitHub のバージョン管理システムには Git が使用されています。\nGitHub を始めてみよう GitHub アカウントを作成しよう GitHubを利用するためにはアカウントを作成する必要があります。\n以下の手順に沿って GitHub アカウントを作成しましょう。\n注意：GitHub アカウントを作成するにはメールアカウントが必要になります。\n GitHub の公式サイトにアクセスしましょう。\nhttps://github.com/ 画面右上の Sign up をクリックしましょう。  メールアドレスを入力後、Continue ボタンをクリックしましょう。  パスワードを入力後、Continue ボタンをクリックしましょう。\n※パスワードは任意の内容でOKです！  ユーザーネームを入力後、Continue ボタンをクリックしましょう。  入力したメールアドレス宛に GitHub から認証コードが送られます。\n届いた認証コードを画面に入力しましょう。\n ここからは個人設定となりますが、必須事項ではないので割愛します。\n画面下部の Skip personnnaization をクリックしましょう。\n 以下の画面が表示されればアカウントの作成は完了です！   リモートリポジトリを作成しよう GitHub アカウントがあれば GitHub 上にリモートリポジトリを作成することができます。\n次の手順に沿って作成してみましょう。\n GitHubにログイン後、Create repository ボタンをクリックしましょう。  以下の画面が表示されましたら、以下の手順でリモートリポジトリを作成しましょう。  リポジトリの名前を設定しましょう。今回は tutorial としましょう。 他のユーザーがリポジトリにアクセスできないように非公開にしましょう。\nPublic を選択すると世界中の GitHub ユーザーがアクセスすることができます。\nPrivate を選択するとリポジトリを作成したアカウントのみがアクセスすることができます。    3. 以下の画面が表示されればリモートリポジトリの作成は完了です！ Point: チームメンバーのみにリモートリポジトリを共有したい場合\nPrivate を選択することで他の GitHub ユーザーはアクセスできなくなりますが、チームメンバーにはアクセスできるようにしたいですよね。\nこのようなときは GitHub のリポジトリへ招待する機能を使いましょう。\n 招待したいリモートリポジトリの画面で Setting を選択しましょう。 Settings 画面の左側に表示されているメニューから Collaborators を選択しましょう。 Add people ボタンをクリックしましょう。 入力欄に GitHub のユーザーネーム（またはメールアドレス）を入力して、招待したいユーザーを選択しましょう。  ファイルをアップロードできるようにしよう GitHub上にリモートリポジトリを用意できましたら、次はファイルをアップロードができるようにしましょう。\nGitHub にファイルをアップロードするための通信手段として、HTTPSとSSHの2種類から選ぶことができます。 HTTPSはデータをそのまま送っているのに対し、SSHは暗号化した上で送るためセキュリティの観点からSSHで通信を行うことを推奨します。\nまた、HTTPSとSSHとではそれぞれ設定の手順が異なりますので注意しましょう。\nHTTPS通信の場合\nHTTPS通信でファイルをアップロードするにはアクセストークンが必要になります。\nこのアクセストークンは GitHub の設定画面で発行することができます。 次の手順に沿って作成してみましょう。\n 画面右上のアイコンをクリックしてしてメニューを表示します。 メニュー内の「Settings」を選択します。\n 「Settings」画面のメニュー内の「Developer settings」を選択する。  「Developer settings」画面のメニュー内の「Personal accesstoken」を選択する。  「Personal accesstoken」画面内の「Generate new token」ボタンをクリックします。  Note に任意の文字列を入力し、画面最下部にある「Generate token」ボタンをクリックします。  発行されたアクセストークンをコピーしましょう。  ファイルをプッシュする際にコピーしたアクセストークンをペーストして実行しましょう。  SSH通信の場合\nSSH（Secure SHell）通信は送信しているデータを暗号化していることが特徴です。\nクライアントマシン（例えば、皆さんのPC）で秘密鍵と公開鍵を生成し、公開鍵を送信先の GitHub に設定することでSSH通信を行うことができます。\nそして、GitHub 側は設定したアカウントと公開鍵を紐づけて管理することになります。 次の手順に沿って作成しましょう。\n  秘密鍵と公開鍵を格納するフォルダに移動しましょう。 ホームディレクトリの直下にある.sshフォルダの直下に秘密鍵と公開鍵を置くことができます。\n以下のコマンドで.sshフォルダに移動しましょう。\ncd ~/.ssh .sshフォルダがない場合は以下のコマンドで削除した上で移動しましょう。\nmkdir ~/.ssh   秘密鍵と公開鍵を生成しましょう。 以下のコマンドで秘密鍵と公開鍵を生成することができます。\nssh-keygen -t rsa コマンドを実行すると以下の３点を確認されます。 ①秘密鍵と公開鍵のファイルの名前 ②秘密鍵と公開鍵のパスフレーズ ③秘密鍵と公開鍵のパスフレーズの再確認\n以下のメッセージが表示されますが、必須の設定ではないためEnterキーをクリックすることでスキップすることができます。\nGenerating public/private rsa key pair. Enter file in which to save the key (/Users/(username)/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again:   秘密鍵と公開鍵が生成されたことを確認しましょう。 lsコマンドで以下の２ファイルが生成されていることを確認しましょう。\n id_rsa id_rsa.pub  生成されたファイルのうち、id_rsa が秘密鍵、id_rsa.pub が公開鍵になります。\n公開鍵である id_rsa.pub の内容を GitHub に設定することになります。\n  公開鍵を GitHub に設定しましょう。\n 「Settings」画面のメニュー内の「SSH and GPG keys」を選択しましょう。 「SSH and GPG keys」画面内の「New SSH key」ボタンをクリックしましょう。 コマンドで公開鍵の内容をコピーしましょう。\n【Macの場合のコマンド】 pbcopy \u003c ~/.ssh/id_rsa.pub 【Windowsの場合のコマンド】 clip \u003c ~/.ssh/id_rsa.pub   で表示した画面の Title に秘密鍵のファイル名を入力し、Key に 3. でコピーした内容を貼り付けましょう。   「Add SSH key」ボタンをクリックしましょう。    SSH接続ができているかを確認しましょう。 次のコマンドでSSH接続ができているかを確認することができます。\n  ssh -T git@github.com 以下のメッセージが表示されれば接続は成功しています。\nHi (account名)! You've successfully authenticated, but GitHub does not provide shell access. 接続がうまくいかなかった場合は手順通りに行えていないところがある可能性があるので、もう一度見直してみましょう。\n",
    "description": "",
    "tags": null,
    "title": "GitHub の基本",
    "uri": "/git-education/basics/github-basics/"
  },
  {
    "content": "プルリクエストとは ここまでの学習内容をマスターできていれば、ローカルリポジトリで変更した内容をリモートリポジトリにアップロードすることができるようになっているはずです。\nあとは変更内容をリモートリポジトリの master ブランチにマージするのみです。\nしかし、ここで安易にリモートリポジトリの master ブランチにマージするのは危険です。\nなぜなら、リモートリポジトリの master ブランチはチームで共有しているため、勝手に更新すると困ってしまうメンバーが出てきてしまうかもしれません。\nまた、そもそもローカルリポジトリで行った変更が正しくなかったり、対応が足りていなかったりする可能性もあります。\nこのようなときは プルリクエスト という GitHub の機能を利用します。\nこの機能を使用すると、簡単に他のメンバーに変更内容のレビューを依頼することができます。\n他のメンバーにレビューしてもらうことで事前にトラブルやリスクを回避することができるのです。\nメモ： GitHub 以外のリモートリポジトリのサービスにもプルリクエストと同様の機能がありますが、\n名称が異なる場合があります。\n例えば、GitLab の場合は同様の機能を「マージリクエスト」と呼称されています。\nプルリクエストを作ってみよう 今回は以下の手順に沿って進めていき、最終的にはプルリクエストを作ってみましょう。\n(1) ローカルリポジトリの develop ブランチで sample.txt の内容を「APPLE」に上書きします。\n(2) リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\n(3) develop ブランチでの変更を master ブランチにマージする内容のプルリクエストを作成します。\n (1) ローカルリポジトリの develop ブランチで sample.txt の内容を「APPLE」に上書きします。\n まずはローカルリポジトリに作業用ブランチである develop ブランチを作成しましょう。\n先程は git branch [ブランチ名] と git checkout [ブランチ名]を実行しましたが、\ngit checkout コマンドのオプション（-b）の後にブランチ名を指定すると、\nこの２つの処理を1つのコマンドで行うことができます。\ngit checkout -b [ブランチ名] 今回は develop ブランチを作成して、同ブランチを作業ブランチにしたいため以下のコマンドを実行します。\ngit checkout -b develop 作業ブランチに切り替わったので、以下のコマンドを実行して sample.txt の内容を「APPLE」となるように上書きしましょう。\necho APPLE \u003e sample.txt 作業が終わったので、以下のコマンドを実行して変更内容をコミットしましょう。\ngit add sample.txt git commit -m \"updated sample.txt\"  (2) リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\n ローカルリポジトリの変更内容をリモートリポジトリに反映しましょう。\n以下のコマンドを実行して、リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\ngit push origin develop コマンドを実行したのち、GitHub上で編集したファイルを確認してみましょう。\n (3) develop ブランチでの変更を master ブランチにマージする内容のプルリクエストを作成します。\n GitHub の画面の [Pull request] をクリックしましょう。 クリックするとプルリクエストの一覧の画面に切り替わります。\n続いて、画面内の「New pull request」ボタンをクリックしましょう。 クリックするとプルリクエストを作成する画面に切り替わります。\nこの際にマージ先のリモートブランチを指定します。\n今回は develop（リモート）の内容を、master（リモート）にマージします。\nこの画面でファイルの差分を確認することができます。\nここで意図しない修正が見つかった場合はローカルリポジトリで再修正した後、 再度リモートリポジトリにプッシュをしましょう。\n内容に問題がなければ「Create pull request」ボタンをクリックしましょう。 最後に、プルリクエストのタイトルとその内容を記載します。\nまた、リモートリポジトリに招待されているアカウントをレビュワーに 指定することができます。\n今回は事前に他のアカウントを招待していないためレビュワーを指定できませんが、\n実際の開発ではここでレビュワーを指定することができます。\nもう一度内容を確認して問題がなければ、「Create pull request」ボタンをクリックしましょう。\nプルリクエストが作成できれば成功です！ プルリクエストが作成されると、レビュワーにメールで通知されます。 （このメールは GitHub アカウントに紐付いているメールアドレスです。） GitHub の画面の [Pull request] をクリックしましょう。\nクリックするとプルリクエストの一覧の画面に切り替わります。\nすると、先ほど作成したプルリクエストを確認することができます。\n仮にレビュワーが変更内容を承認した場合はチェックマークが表示されます。 今回はレビュワーがいないためレビュワーから承認があったと仮定して、 最後にリモートリポジトリの master ブランチにマージしてみましょう。\nまずは「Merge pull request」ボタンをクリックします。\nすると、「Confirm merge」ボタンが表示されます。\nこのボタンをクリックすると 、リモートリポジトリの master ブランチと develop ブランチをマージし、\nマージをしたという内容のコミットログを生成されます。\n「Confirm merge」ボタンをクリックするとマージが完了しますが、その後「Delete branch」ボタンが表示されます。 このボタンをクリックするとリモートリポジトリの作業ブランチ（develop ブランチ）が削除されます。\n同じ作業ブランチを残しておきたい場合はクリックする必要はないですが、不要な場合はこのボタンをクリックして削除しましょう。 これでリモートリポジトリの master ブランチに変更内容が反映されました。\n本当に反映できているかを以下の手順で確認をしてみましょう。\n(1) ローカルリポジトリの作業ブランチを master ブランチに切り替えます。 (2) リモートリポジトリの master ブランチから最新のファイルをダウンロードします。\n (1) ローカルリポジトリの作業ブランチを master ブランチに切り替えます。\n 以下のコマンドを実行して作業ブランチを master ブランチにしましょう。\ngit checkout master  (2) リモートリポジトリの master ブランチから最新のファイルをダウンロードします。 以下のコマンドを実行して、リモートリポジトリの master ブランチから最新のファイルをダウンロードしましょう。\n git pull origin master コマンド実行後に cat コマンドで sample.txt の中身を確認してみましょう。\nファイルの内容が「APPLE」になっていれば成功です！¥\n",
    "description": "",
    "tags": null,
    "title": "GitHub のプルリクエスト機能",
    "uri": "/git-education/advanced/pull-request/"
  },
  {
    "content": "以上が基本編の内容となります。基本編では Git の基礎的な知識やコマンドをおさえました。\nこれで一人で Git にファイルの変更履歴を残しながら開発を進めることができるようになったはずです。\nしかし、チーム開発では基本編の知識だけでは不足しています。\n応用編ではチーム開発で必要となる知識とコマンドをおさえていきましょう。\n",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/basics/summary/"
  },
  {
    "content": "応用編では Git でチーム開発を行う方法について学習しました。\nGit の開発フローを理解できれば実際に活用するのは難しくありません。\n実際の開発で使用する Git のコマンドはさほど多くはありません。\nそれぞれのコマンドの意味を一つずつ確実に理解をしていきましょう。\nこの度紹介した開発フローとコマンドで事足りますが、\nGit を活用してもいろいろなトラブルが発生します。\n例えば、複数人が同じファイルを同じ箇所を同時に変更されたり、\n一度 Git にコミットした内容を取り消したいなどがあります。\nこのようなトラブルが起きたときはどのように解消したらよいかを 実践編 でお伝えします。\n",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/advanced/summary/"
  },
  {
    "content": "Git X EDU 本コンテンツはバージョン管理システムである Git を習得するためのコンテンツです。\n現在の開発現場では Git の操作は必須のスキルです。\n本コンテンツを終了する頃には Git を使用してファイルの変更履歴を遡ったり、\nチームメンバーとお互いにコードレビューができるようになっているでしょう。\nペルソナ Git を初めて学ぶ、もしくは Git を触り始めて日が浅い方が本コンテンツの受講者と想定しています。\n前提条件  基本的な linux コマンドを習得していること  準備物  Mac の場合  ターミナル   Windows の場合  GitBash    linux コマンドを実行できるコンソールアプリであれば、上記のアプリ以外でも問題ありません。\nカリキュラム 本コンテンツは「基礎編」、「応用編」、「実践編」の３つで構成されています。\n「基礎編」→「応用編」→「実践編」の順で進めていきましょう。\n基礎編 Git でバージョン管理をする上で最低限必要となる知識を身につけます。\n応用編 Git でチーム開発をする上で必要となる知識を身につけます。\n実践編 Git でトラブルが発生した際に解消する知識を身につけます。\n補足資料 基本的な Git コマンド一覧 本コンテンツで紹介した基本的な Git コマンドの一覧です。\n",
    "description": "",
    "tags": null,
    "title": "Git X EDU",
    "uri": "/git-education/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/git-education/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/git-education/tags/"
  }
]
