[
  {
    "content": "Git で起こるトラブル 基礎編と応用編を通して Git の操作にはある程度の自信がついたのではないのかなと思います。\n実際に開発プロジェクトでは基礎編と応用編の知識を活かすことで開発を進めることができるでしょう。\nしかし、実際の開発プロジェクトでは様々なトラブルが起きるのです。\nこの実践編ではよくあるトラブルを解消をする方法を学んでいきましょう。\n競合の解消 競合とは 変更内容をマージする際に、同じファイルの同じ行が既に変更されていると衝突してしまい「競合（コンフリクト）」と呼ばれる事象が発生します。\n競合が発生すると、２つの履歴のうちどちらの変更が正しいかは Git が判断することができないため同ファイルのマージが中断されます。\nマージの際に競合が発生すると以下のようなメッセージが表示されます。\nAuto-merging sample.txt CONFLICT (content): Merge conflict in sample.txt Automatic merge failed; fix conflicts and then commit the result. チーム開発をしていると競合が起きるのも珍しくありません。 そして、競合が起きるのは決して悪いことではありません。 大事なのは履歴のうちどちらの変更が正しいかの判断を間違えないことです。\n競合を解消してみよう 競合を解消すると開発者はつぎのいずれかの選択肢を取ることになります。\n マージを中止してマージ前の状態に戻す 競合を解消してマージをする  今回は両方とも試してみましょう。\n マージを中止してマージ前の状態に戻す\n その場で競合の解消が難しいなどの理由でどうしてもマージができない場合があります。\nそのようなときは、以下のコマンドで実行して git merge コマンドを中止することができます。\ngit merge --abort これは競合の解消ではなくマージを中断しただけのため、\n競合箇所を修正せずに再度マージをすると再び競合が発生します。\n 競合を解消してマージをする\n まずは競合を起こしているファイルを開きましょう。\n競合が起きている部分はハイライトされているためわかりやすくなっています。\n「«« HEAD」〜 「==========」が main ブランチにマージされている内容、\n「==========」〜 「»» develop2」が develop2 ブランチの内容となっています。\n今回は develop2 ブランチの内容を正しいということにしましょう。\nハイライトと main ブランチにマージされた内容を削除して、\ndevelop2 ブランチの内容だけを残すようにしましょう。\nインデックスにはまだマージ前のファイルが記録されているため、\n競合を解消したファイルを git add コマンドで再度インデックスに追加する必要があります。\n今回は以下のコマンドを実行して、 sample.txt をインデックスに追加しましょう。\ngit add sample.txt あとはコミットをするだけです。\nコンフリクトを解消したコミットはデフォルトでメッセージが生成されます。\nメッセージは付与せずに以下のコマンドを実行してみましょう。\ngit commit 競合が起きないように開発者ごとに編集できるファイルを限定させるという運用ルールを設けることもできますが、これではチーム全体の作業効率を下げてしまうことになります。\n慣れれば競合は恐いものではないので、ぜひ競合が起きた際は解消に挑戦してみましょう！\n",
    "description": "",
    "tags": null,
    "title": "競合の解消",
    "uri": "/git-education/practical/conflict/"
  },
  {
    "content": "基礎編をマスターすることができたのであれば、Git 管理をしながら開発することに自信を持つことができていると思います。\nしかし、チーム開発で Git を扱うにはまだ不十分です。\n例えば、次のような状態になったとき、あなたはどうしますか？\nあらまし 仮にチーム内で開発者とテスターが分かれていた場合でのお話です。 開発者AはテスターBにソースを渡すため、リモートリポジトリに変更を加えたソースを push しました。 ところが、テスターBが pull をしてテストをしたところバグが見つかりました。 そこで、テスターBは開発者Aにバグがあることを伝え、修正を依頼しました。 一見問題はなさそうですが、もし別の開発者Cがいた場合はどうでしょう？ 開発者Cももちろんリモートリポジトリから最新のソースを取得して開発をおこないます。 リモートリポジトリから取得したソースにバグがあった場合、開発者Cにも影響を与えてしまいます。 このようなときに ブランチ は活躍します。\nブランチの運用方法は様々ですが、今回はデフォルトの main ブランチの他に開発用のブランチ（ develop ブランチ）を作成する運用をすることで今回の問題は解消されます。 ここからはブランチについて学んでいきましょう。\n",
    "description": "",
    "tags": null,
    "title": "Git と チーム開発",
    "uri": "/git-education/advanced/team-development/"
  },
  {
    "content": "Chapter 1 基礎編 Git でバージョン管理をする上で最低限必要となる知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "基礎編",
    "uri": "/git-education/basics/"
  },
  {
    "content": "Git の基本 皆さんがこれから学ぶのは Git は、ファイルの変更履歴を記録できるバージョン管理システムです。 以下は Git を活用した場合のメリットの一部です。このように Git を活用するとより効率的に開発を進めることができます。\n 編集したファイルを過去の状態に戻すことができる 複数人で同じファイルを同時に編集することができる 編集の意図をコメントして残すことができる  本チャプターでは Git の基本を実際にコマンドを実行していきながら学んでいきます。\nまずは Git のことを知る前に、事前知識としてリポジトリとバージョン管理システムの概要から理解していきましょう。\nリポジトリとは 突然ですが、パソコンで作成したファイルはファイルはどこに保存されているかを意識していますか？\n後で探しやすいようにデスクトップに格納する場合もあれば、書類であればドキュメントフォルダに格納することもあるでしょう。\nしかし、そこに格納されているのはファイル本体だけで、ファイルの変更履歴は残っていません。\n一方でファイルだけでなく、そのファイルの変更履歴を記録することができるのがリポジトリです。\nリポジトリは通常のディレクトリ（フォルダ）とは異なり変更履歴を記録しているため、過去の状態を確認したり、過去の状態に戻すことができます。\nリポジトリの作り方は後ほど解説しますが、この後リポジトリという用語が何度も登場するので用語の意味をしっかり覚えておきましょう。\n Note リポジトリ：ファイルやその変更履歴の格納場所\n  バージョン管理システムとは バージョン管理システムはその名の通り、ファイルの変更履歴（バージョン）を管理するシステムです。\nチームでクラウド（ネットワーク）上にあるリポジトリを共有することで手分けをしながら作業ができるようになります。\nファイルに対して誰が、いつ、どのような変更をしたのかを記録することができます。 この記録は先述したリポジトリに蓄積されていきます。\nまた、変更内容の差分を確認したり、任意のバージョンに戻すことができます。\n Note バージョン管理システム：ファイルに対して「誰が」「いつ」「どのような変更をしたか」を記録し、変更の差分や変更前の状態に復元することができるシステム\n  バージョン管理システムには 分散型 と 集中型 の２種類があります。\nGit は分散型に分類されるのですが、それぞれの違いについて確認していきましょう。\n集中型バージョン管理システム 集中型はリポジトリはクラウド（ネットワーク）に１つのみ存在し、チームメンバーはこのリポジトリに接続して作業を行います。 仕組みは至ってシンプルで、チームメンバーは各自必要なファイルのみをダウンロードして編集します。\n編集を終えたら、その編集履歴をクラウド（ネットワーク）上にあるリポジトリにアップロードするという流れになります。\n分散型と異なるのは変更を加えた場合はその都度アップロードをする必要があることです。\nそのため、集中型には以下のデメリットがあります。\n 作業が完了していない状態（エラーが発生する状態）でアップロードをすると、チームメンバーに悪影響を与える可能性があります。 必要なファイルのみをダウンロードしているため、アップロードしてみないとテストができない。  分散型バージョン管理システム リポジトリはクラウド（ネットワーク）上に１つだけではなく、各チームメンバーのデバイス内にも存在します。 各メンバーは自身のデバイス内のリポジトリに対して、ファイルの編集内容を記録していき、 最終的にはデバイス内リポジトリとクラウド（ネットワーク）上のリポジトリを統合（マージ）します。\nそのため、分散型には以下のメリットがあります。\n 自身の編集（コミット）が他のメンバーへ影響を与えない。 ローカルリポジトリでテストをしてからリモートリポジトリで共有できる。  また、このリポジトリはローカルリポジトリとリモートリポジトリの2種類に分けられます。\nローカルリポジトリは操作しているデバイスの中にあるリポジトリのことを指します。\n自身のみがアクセスして編集を行うためのリポジトリで、基本的にこのローカルリポジトリでファイルを編集します。\n一方のリモートリポジトリはその名の通り操作しているデバイスの中にはなくクラウド（ネットワーク）上にあるリポジトリで、複数のチームメンバーと共有することができます。\n個人の作業をローカルリポジトリで行い、その作業で作成したファイルをリモートリポジトリにアップロードすることで他のチームメンバーと共有できる仕組みになっています。\nアップロードしない限りチームメンバーにファイルを共有することができませんが、ローカルリポジトリでエラーが発生したとしてもアップロードしない限りチームメンバーに影響与えることはありません。\n Note ローカルリポジトリ： 操作しているデバイスの中にある自分専用のリポジトリ\nリモートリポジトリ：クラウド（ネットワーク）上にある共有のリポジトリ\n  ちなみに、Git はこの分類型バージョン管理システムに該当します。\n必要となる事前知識はここまでです。ここからは本格的に Git を学んでいきましょう。\nGit とは Git は分散型バージョン管理システムでファイルを管理するシステムの１つです。\nこの Git を活用することでリポジトリを作り、ファイルの履歴管理をすることができます。\nGit の使い方についてはこれから実際に試しながら学んでいきましょう。\nまた、Git を触っていると以下のようなハッシュ値をよく見かけると思います。\n以下は後々登場する Git のコミットログです。\ncommit 5c670db6fc4a8d109a5e2724c421cd8105c2598f (HEAD -\u003e master) 実は Git により自身の編集（コミット）ごとに重複することのないハッシュ値が割り当てられています。 このハッシュ値はSHA-1ハッシュと呼ばれており、16進数の文字（0-9とa-f）で構成された40文字の文字列です。 ファイルの内容もしくは Git 内のディレクトリ構造を元に計算されます。\nこれは Git が内部でもっているデータベースの中で管理するために割り当てられているのです。\nそのため、Git はこのファイルはいつどのように変更したのかという観点は意識しておらず、 この編集でどのファイルをどのように変更したのかという観点で管理をしています。\nGit を始めてみよう Git の公式サイトからインストーラーをダウンロードすることができます。\n以下のURLからインスト＝ラーをダウンロードして Git をインストールしましょう。\nhttps://git-scm.com/downloads\nGit のインストールが完了しましたら、インストールが完了できているかを確認しましょう。\nターミナルを起動して、インストールされている Git のバージョンを確認するコマンドを実行しましょう。\n以下のコマンドを実行して、git version X.X.X (※) がターミナル上に表示されればインストールは完了できています！\n※Xの部分には数値が表示されます。\ngit --version Git のインストールができていることが確認できたら、続いて初期設定を進めていきましょう。\nGit は「誰が」が残した履歴なのかを記録していくため、Git のユーザー情報（ユーザー名とメールアドレス）を登録する必要があります。\nユーザー名は以下のコマンドで登録することができます。\n※“XXXXXX”の箇所は任意のアカウント名を指定してください。後ほど設定する GitHub のアカウント名と同じである必要があります。\ngit config --global user.name “XXXXXX” メールアドレスは以下のコマンドで登録することができます。\n※“XXXXX@XXXXXX”の箇所は任意のメールアドレスを指定してください。後ほど設定する GitHub のアカウントのメールアドレスと同じである必要があります。\ngit config --global user.email \"XXXXX@XXXXXX\" ユーザーの情報が正しく設定されているかは以下のコマンドで確認することができます。\nコマンド実行後に設定したアカウント名とメールアドレスが表示されればOKです。\ngit config user.name git config user.email ",
    "description": "",
    "tags": null,
    "title": "Git の基本",
    "uri": "/git-education/basics/git-basics/"
  },
  {
    "content": "コミットの比較 ファイルを更新すると、「意図した通りに更新できているかな？」や「意図していないところを更新していないかな？」とファイルの更新前後の差分を確認したくなるときがあると思います。\nこのようなときは git diff コマンドを使いましょう。\nこのコマンドは指定した2点間のファイルの差分を確認できます。\ngit diff DEMO\n今回は sample.txt の内容を「APPLE」から「ORANGE」に上書きして差分を確認してみましょう。 以下のコマンドで上書きと更新前後の差分の確認をしてみましょう。\necho ORANGE \u003e sample.txt git diff diff --git a/sample.txt b/sample.txt index e427984..fd0eebf 100644 --- a/sample.txt +++ b/sample.txt @@ -1 +1 @@ -HELLO +ORANGE +マークは追加された行で、-マークは削除された行を意味しています。\n上記の実行結果では -HELLO は HELLO が削除されたということ、 +ORANGE は ORANGE が追加されたことがわかります。\nまた、以下のコマンドで、現在はファイルと指定したコミットの差分を確認することができます。\ngit diff [コミットのハッシュ値] また、特定のコミット間の比較をすることもできます。\ngit diff [比較元のコミットのハッシュ値] [比較先のコミットのハッシュ値] ローカルリポジトリ内だけでなく、リモートブランチとも差分を比較することができます。\nこの場合はあらかじめ比較先のリモートブランチを git fetch コマンドで参照をダウンロードしておきましょう。\ngit fetch origin [リモートリポジトリのブランチ名] git diff [ローカルリポジトリのブランチ名] origin/[リモートリポジトリのブランチ名] ",
    "description": "",
    "tags": null,
    "title": "コミットの比較",
    "uri": "/git-education/practical/difference/"
  },
  {
    "content": "Chapter 2 応用編 Git でチーム開発をする上で必要となる知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "応用編",
    "uri": "/git-education/advanced/"
  },
  {
    "content": "ブランチとは 1つのプロジェクトから分岐させることにより、共有しているプロジェクトに影響を与えずに開発ができる機能です。\nブランチを切ることにより、同時並行で目的別に作業をすることができます。\n※ブランチを作ることを「ブランチを切る」と言います。\nGit は master ブランチがデフォルトになっており、実は初級編では master ブランチで作業をしていました。\n現在作業をしているブランチは以下のコマンドで確認をすることができます。\ngit branch git branch コマンドを実行すると、ローカルリポジトリ内のブランチ名の一覧を以下のように表示されます。 注意： Git のコミットログがない場合はブランチ名は表示されないので、git commit を実施した上でgit branchコマンドを実行しましょう。 現在作業しているブランチの左隣に*が表示されます。\nいまは master ブランチしかないため表示されるブランチ名を1つのみですが、\nブランチを増やすと現在作業していないブランチの名前もこのコマンドで確認することができます。\n* master 一般的な開発プロジェクトでは master ブランチの内容が納品物（テストが完了した最新のソースコード）となるため、\n機能の改修や追加する場合はこの master ブランチから開発用のブランチを切った上で作業を行います。\n注意： ローカルリポジトリと同様にリモートリポジトリ（GitHubなど）にもブランチが存在します。\nリモートリポジトリのブランチは git push コマンドを実行する際に生成されます。\nブランチを使ってみよう それでは開発用のブランチを作ってみましょう。 ブランチ名は自由につけることができますが、今回のブランチ名は develop にしましょう。\ngit branch コマンドの後ろに作成したいブランチの名前を指定すると同じ名前のブランチを作ることができます。\ngit branch develop 再度 git branch コマンドを実行すると以下のようにブランチの一覧が表示されます。\ndevelop ブランチが作成できているかを確認してみましょう。\n develop * master develop ブランチができていることが確認できたと思いますが、現在作業しているブランチを意味する*は master ブランチの左隣にあります。\nつまり、ブランチを作ることができたものの、作成したブランチ（develop）を作業ブランにすることができていません。\nまだ master ブランチが作業ブランチとなっている状態のため、作業ブランチを develop ブランチに切り替えてみましょう。\nブランチの切り替えは git checkout コマンドで行うことができます。\ngit checkout [切り替えたいブランチの名前] 注意：切り替えようとしたブランチがない場合はエラー（error: pathspec '存在しないブランチ名' did not match any file(s) known to git）が発生するので、git checkout コマンドを実行する前にあらかじめブランチを作っておきましょう。\n今回は develop ブランチに切り替えたいので、以下のコマンドを実行しましょう。\ngit checkout develop それでは再度 git branch コマンドで develop ブランチが作業ブランチになっているかを確認してみましょう。 develop の左隣に * があればブランチの切り替えに成功です！\n* develop master 続いて、切り替えた develop ブランチでファイルを編集をしてみましょう。\nmaster ブランチで作成した sample.txt には hello と書かれていますが、\nこれを develop ブランチでは HELLO に上書きをします。\necho HELLO \u003e sample.txt ファイルの上書きのコマンドを実行できましたら、cat コマンドでsample.txtが上書きできているかを確認しましょう。\ncat コマンドの実行結果が以下の通りであれば成功です。\nHELLO ではここで、git status コマンドでステータスを確認してみましょう。\nOn branch develop Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: sample.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") On branch develop は develop ブランチで作業していることを意味しています。\nChanges not staged for commit　は修正はしたもののまだ git add を実行していないため、\nコミットができないファイルをあるよという意味です。\nその下に modified: sample.txt と表示されていますが、これは sample.txt に変更が発生しているという意味になります。\nそれでは以下のコマンドを実行して、今回編集した sample.txt の変更内容を Git に登録してみましょう。 ブランチ名が変わってもこのフロー（ステージ済 → 修正済 → コミット済）は変わりません。\ngit add sample.txt git commit -m \"develop commit\" コミットが無事完了できたかをgit log コマンドで確認してみましょう。\nコミットのメッセージが develop commit となっているコミットログが残っていれば成功です！\ncommit 1be05c74b8ae9ce1f8b1a09510b1367c88e1100e (HEAD -\u003e develop) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 11:21:55 2022 +0900 develop commit commit 5db36ee820d446e27838869e79cbae3526f71a8f (master) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit ではここで、また master ブランチに戻ってみましょう。\nブランチの切り替える git checkout コマンドで master ブランチに戻ることができます。\ngit checkout master ここで再度 git log コマンドを実行してコミットログを確認してみましょう。\nすると、さきほど develop ブランチでコミットした develop commit がないことが確認できます。\ncommit 5db36ee820d446e27838869e79cbae3526f71a8f (HEAD -\u003e master) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit 念のため develop ブランチで編集した sample.txt の内容を cat コマンドで確認してみましょう。\n以下のように develop ブランチで変更を加える前の状態になっていることが確認できます。\nこれは develop ブランチの作業が main ブランチに影響を与えていないことを意味しています。\nhello このようにブランチを活用すると、他のブランチに影響を与えることなく作業することができます。\n",
    "description": "",
    "tags": null,
    "title": "Git のブランチ機能",
    "uri": "/git-education/advanced/branch/"
  },
  {
    "content": "Git の基本コマンド Git の操作方法は GUI と CUI に分けられます。\nGit の GUI を利用すれば、マウスを使って画面上のアイコンやウィンドウを使用すると簡単に Git を操作することができます。\nしかし、以下の理由からコマンドで Git を操作する CUI で学習をすることをお勧めします。\n つまづいたとき、実行したコマンドと表示されたエラーを元にネットで検索をすることで原因が特定しやすい Git に関する記事は GUI よりも CUI の方が圧倒的に多い 実行した内容がログとして残るため、自分がどのような操作をしたのかという証跡が残る  そのため、ある程度慣れたのであれば GUI で Git を操作してもよいと思いますが、この教育コンテンツでは CUI（コマンド）で操作を行います。\nここからは基本的な Git コマンドを紹介します。実際に Git コマンドを実行しながら確認をしていきましょう。\nGit コマンドを実行するにはまずローカル（皆さんのPC内）に Git で管理されているディレクトリを用意する必要があります。 Git で管理されているディレクトリを作成する方法は git init と git clone の２種類があります。\nそれぞれの違いを確認していきましょう。\n 既存ディレクトリを Git 管理する git init コマンドにより既に作成済みのディレクトリ（フォルダ）をローカルの Git リポジトリにすることができます。\n同コマンドを実行すると、指定したディレクトリに 「.git」 という隠しディレクトリが作成されます。\nこの「.git」ディレクトリが配下にあるディレクトリは Git リポジトリとして扱われます。\ngit init [Gitリポジトリにしたいディレクトリのパス（省略可）] [Gitリポジトリにしたいディレクトリのパス]は省略することもでき、その場合はカレントディレクトリ（cdコマンド等で移動した現在のディレクトリ）が Git リポジトリとなります。\nDEMO\n今回はデスクトップ上に git-tutorial ディレクトリを作成して、作成した同ディレクトリを Git リポジトリにしてみましょう。\ncd /Users/UserName/Desktop mkdir git-tutorial git init git-tutorial コマンド実行時に Initialized empty Git repository in /Users/UserName/Desktop/git-tutorial/.git/と表示されれば成功です。 ※上記のメッセージのうち、UserNameにはOSにログインしているユーザー名が表示されます。\ngit-tutorial フォルダを Git リポジトリにすることができたら、git-tutorial フォルダの配下に「.git」ディレクトリがあることを確認しましょう。\ncd git-tutorial ls -al これで Git リポジトリを作ることができました。この 「.git」 の中に過去のファイル・ディレクトリの状態が蓄積されていきます。\n リモートリポジトリをクローンする GitHubなどに存在するリモートリポジトリをローカルにクローン（コピー）して開発を始めることもできます。\n実際の開発ではチームで１つのリポジトリを共有して利用するため、チームメンバーのひとりがリモートリポジトリを作成して、\n残りのメンバーはそのリポジトリをクローンするところから開発が始まることが一般的です。\nこれを実現するのが git clone コマンドで、コマンドの後ろにはクローンしたいリポジトリのURLを指定します。\ngit clone [リモートリポジトリのURL] [クローン先のディレクトリのパス（省略可）] [クローン先のディレクトリのパス（省略可）]は省略することもでき、\nその場合はカレントディレクトリ（cdコマンド等で移動した現在のディレクトリ）の配下にクローンした Git リポジトリが生成されます。\nDEMO 今回は GitHub 上にある git_tutorial リポジトリをローカルのデスクトップにクローンしてみましょう。\ncd /Users/UserName/Desktop git clone https://github.com/a-nakamura1015/git_tutorial.git コマンド実行後にデスクトップ上に git_tutorial ディレクトリがあることと、その配下に 「.git」 があることを確認してみましょう。\nそのため、クローンするだけでそのディレクトリ配下で Git の操作をすることができます。\n ローカルリポジトリにリモートリポジトリを追加する ローカルリポジトリとリモートリポジトリを紐づけるコマンドもあるので紹介します。\ngit remote addコマンドでリモートリポジトリの名前（origin）とリモートリポジトリのURLを設定することで実現できます。\ngit remote add [リモートリポジトリの名前] [リモートリポジトリのURL] リモートリポジトリにはデフォルトでoriginという名前がついているので、この名前とリモートリポジトリのURLを紐付けるのが一般的です。\nまた、ローカルリポジトリが現在どのリモートリポジトリと紐づいているかは以下のコマンドで確認をすることができます。\ngit remote -v 一方で一度紐づけたリモートリポジトリとの紐付けを解除することもできます。\ngit remote rm [リモートリポジトリの名前] DEMO\n今回はデスクトップ上に remote ディレクトリを作成して、git_tutorial リポジトリをリモートリポジトリとなるように設定してみましょう。 まずは以下のコマンドでデスクトップ上に remote ディレクトリを作成して、remote ディレクトリをカレントディレクトリにしましょう。\ncd /Users/UserName/Desktop mkdir remote cd remote remote ディレクトリに移動ができたら、git initで remote ディレクトリを Git リポジトリにしましょう。\ngit init 続いて、以下のコマンドでリモートリポジトリを紐付けましょう。\ngit remote add origin https://github.com/a-nakamura1015/git_tutorial.git 以下のコマンドで火もづいているリモートリポジトリを確認してみましょう。\ngit remote -v 以下のような結果が表示されれば成功です。\norigin\t/Users/UserName/Desktop/remote/ (fetch) origin\t/Users/UserName/Desktop/remote/ (push) 最後にリモートリポジトリとの紐付けを解除してみましょう。\n先ほどリモートリポジトリのURLを設定した際に指定したリモートリポジトリの名前は origin なので以下のコマンドを実行しましょう。\ngit remote rm origin これでリモートリポジトリの紐付けがなくなりました。試しにgit remote -vを実行してみても結果は何も表示されません。\nここまではローカルに Git リポジトリを作成するコマンドを紹介してきました。\nここからは本命のファイルの変更履歴を残す・確認するコマンドを紹介しますが、 「既存ディレクトリを Git 管理する」で作成した git-tutorial ディレクトリでコマンドの動作を確認していきます。\n以下のコマンドを実行した上で次に進みましょう。\ncd /Users/UserName/Desktop/git-tutorial  現在のステータスを確認する まずはGitリポジトリ内の状態を確認する git status コマンドを紹介します。\n後ほどファイルの状態をご紹介しますが、編集したファイルがどのような状態であるかを確認することができる コマンドです。\ngit status git-tutorial ディレクトリでこのコマンドを実行すると、以下の内容が表示されます。\nOn branch master No commits yet nothing to commit (create/copy files and use \"git add\" to track) On branch master はカレントブランチ(※1)が master であることを意味します。 No commits yetはコミット(※2)がまだないことを意味します。\n※1 ブランチは、同じプロジェクトで同時変更で作業を進めるための仕組みです。ブランチは応用編で解説します。 ※2 コミットは Git が管理しているリポジトリ内のログに変更履歴を残す操作のことです。 本編で解説します。 まだコミットをしていないので画面上にはNo commits yetと表示されています。\nこの後いくつかの Git コマンドを実行してステータスを変えていくので、その際にこのコマンドで状態を確認していきましょう。\n ３つのエリア Git でファイルの変更履歴を登録する過程には３つのエリアがあります。\nGit の操作の流れを理解をする上でとても重要な観点ですので、しっかり押さえておきましょう。\nGit はファイルを変更してもその内容がローカルリポジトリに反映されることはありません。\n変更したファイルを指定して、その変更内容をまとめて変更履歴に残すという流れになります。\nわかりやすく言い換えると、変更内容を記録に残したいファイルを撮影台（ステージングエリア）にあげて、\n撮影台に乗っている記録のキャプチャショットを撮るというイメージです。\n 作業ディレクトリ\nファイルの作成、更新、削除といった作業を行うエリアです。Gitリポジトリ内で何らかの変化があると Git はそれを検知してくれます。 ステージングエリア\nGit が検知した変化のうち、Gitの変更履歴に残したいものが置かれているエリアです。\ngit addコマンドで記録したい変更履歴を撮影台（ステージングエリア）に上げることができます。 ローカルリポジトリ\nファイルの変更履歴が蓄積されているエリアです。\ngit commitコマンドで撮影台に乗っている乗っている残したい記録のキャプチャショットを撮ることができます。  イメージだけではなかなか理解には至らないと思うので、実際に Git を操作して確認をしていきましょう。\n 変更内容をステージングエリアに追加する 新規追加・変更したファイルは git add コマンドでステージングエリアに追加することができます。\nコマンドの後ろにはステージングエリアに追加したいファイルのパスを指定します。\ngit add [編集したファイルのパス] DEMO\n今回は sample.txt を新規で作成して、同ファイルをステージングエリアに追加してみましょう。 ①ファイルを新規で作成してみよう まずは以下のコマンドで sample.txt を作成します。\ntouch sample.txt 続いて、作成したファイルに hello と書き込みます。\necho hello \u003e sample.txt cat コマンドで sample.txt に hello と書き込みができているかを確認してみましょう。\ncat sample.txt ここで一旦ステータスを確認してみましょう。\ngit status git statusコマンドを実行すると以下の結果が表示されます。\nOn branch master No commits yet Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) sample.txt nothing added to commit but untracked files present (use \"git add\" to track) 着目する点は Untracked files です。\nこれはまだ Git の管理下に置かれていないファイルがあることを意味します。\nUntracked filesの後ろに sample.txt があるので、このファイルがまだ Git の管理下に置かれていないということです。\nGit の管理下に置かれるようにするには git add コマンドを実行する必要があります。\n②ファイルのステータスを修正済にする それでは、git add コマンドを実行してみましょう。\ngit add sample.txt git add コマンドを実行すると、以下の内容が表示されます。\nOn branch master No commits yet Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: sample.txt git add コマンドの実行前は Untracked files でしたが、実行後は Changes to be committed に変わりました。 これはファイルのステータスが修正済に変わり、コミットの対象になっていることを意味します。 今回は新しいファイルを Git に追加しようとしているため new file: sample.txtと表示されています。  変更内容をコミットする 変更内容をステージングエリアに追加されていると、その変更内容を Git の履歴に追加できるようになります。\nこの Git の履歴に追加する操作をコミットといいますが、コミットは以下のコマンドで実行することができます。\ngit commit このコマンドはファイルそのものを保存しているのではなく、ファイルの変更履歴を保存することができるというところがポイントです。\nコミット時のスナップショットを撮って、その記録をローカルリポジトリに保存をするというイメージです。 また、コミットの際に任意のメッセージを残すことができます。\n以下のコマンドのように、コマンドの後ろにオプション（-m）を指定して、その後に登録したいメッセージを入力します。\n実際の開発プロジェクトでは「このコミットでどのような対応を行なったか」をメッセージに残すことになります。\nなぜなら、大量のコミットのログの中から特定のコミットを探す作業が容易になり、 またチームメンバーにもどのような対応をしたのかを共有することもできるからです。\ngit commit -m \"message\"   Warning メッセージはクォーテーションで囲う必要があります。\n  DEMO\n今回は先ほど修正済（git add コマンドを実施済）となった sample.txt の新規追加する内容を Git の変更履歴に登録しましょう。\nコミットのメッセージにはfirst commit と入力しましょう。（今回のメッセージは英語でしたが、日本語を入力することも可能です。）\ngit commit -m \"first commit\" コマンドを実行すると以下のメッセージが画面に表示されます。\n[master (root-commit) 5c670db] first commit 1 file changed, 1 insertion(+) create mode 100644 sample.txt それでは、再度ステータスを確認してみましょう。\ngit status コマンドを実行すると以下のメッセージが画面に表示されます。\nOn branch master nothing to commit, working tree clean コミットを行なったことにより修正済のファイルがコミット済となったため、nothing to commit, working tree clean と表示されます。\nDEMO\nでは、もう一つデモを試してみましょう。\n先ほどは新規ファイルを Git に登録して、そのファイルの内容を Git に登録しました。\n今度は既存ファイルの変更内容を Git に登録してみましょう。\nまずは既存のファイル（sample.txt）に good と追記しましょう。\necho good \u003e\u003e sample.txt cat コマンドで sample.txt に good と追記ができているかを確認してみましょう。\ncat sample.txt ここで一旦ステータスを確認してみましょう。\nOn branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: sample.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 2行目のChanges not staged for commitはコミット対象の変更がステージングエリアにはないという意味です。\n5行目のmodified: sample.txtは sample.txt に変更があったことを意味します。\n最後のno changes added to commitは2行目と同じ意味で、コミットするものがないことを意味します。\nそれでは、git addコマンドで sample.txt の変更内容がコミット対象となるようにしましょう。\ngit add sample.txt もう一度ステータスを確認してみましょう。\nOn branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: sample.txt 2行目がChanges to be committedに変わりました。これはステージングエリアにある変更がコミットできるようになっていることを意味します。\n最後にコミットができるかを試してみましょう。\n先ほどのコミットと区別がつくようにコミットメッセージを second commit に変えておきましょう。\ngit commit -m \"second commit\"  コミットログを確認する Git はコミットした履歴（コミットログ）を以下のコマンドで確認することができます。\ngit log コマンドを実行すると以下のようなログが表示されます。\ncommit 0336368ff10d1f69849cd5beeda1cf1ed274bb6d (HEAD -\u003e master) Author: corgi9n \u003carapon1015@gmail.com\u003e Date: Fri Mar 11 03:54:55 2022 +0900 second commit commit 5c670db6fc4a8d109a5e2724c421cd8105c2598f Author: corgi9n \u003carapon@gmail.com\u003e Date: Fri Mar 11 03:44:55 2022 +0900 first commit commit 0336368ff10d1f69849cd5beeda1cf1ed274bb6d (HEAD -\u003e master)のうち、 0336368ff10d1f69849cd5beeda1cf1ed274bb6d はコミットのハッシュ値で、このハッシュ値で一意のコミットを特定することができます。  (HEAD -\u003e master)は HEAD の内容を master ブランチに履歴を残したということを意味します。（この内容については応用編で解説します。） Authorは Git のコミットを残した Git アカウントが表示され、Dateはコミットした日時が表示されます。\nさらに下にはコミットの際に残したメッセージが表示されます。\n Info もし、git log コマンドを実行した後、表示されたログの下に : が表示されている場合は、 続けてコマンドを実行することができません。\nこの場合は q を入力して Enter キーを押すことで再度コマンドが実行できるようになります。\n   変更内容をリモートリポジトリに反映する 先ほどはコミットを完了して、ファイルの変更内容を無事コミットログに残すことができました。\nこれでやりたいことが終わったように感じますが、まだやらなければならないことが残っています。\nチーム開発している場合はリモートリポジトリでソースコードを共有しているため、\nファイルを編集した場合はリモートリポジトリにアップロードして、チームメンバーと共有できるようにする 必要があります。\n変更内容（コミットログ）をリモートリポジトリにアップロードするには、\ngit push コマンドを実行します。\ngit push origin [リモートリポジトリの名前] [リモートリポジトリのブランチ名] DEMO 今回は以下のコマンドを実行して、リモートリポジトリの main ブランチにアップロードをしてみましょう。\ngit push origin main コマンドを実行するとパスワードの入力を求められます。\nこれは GitHub アカウントに対して2段階認証を設定したため GitHub アカウントのパスワードを求められています。\nGitHub アカウントのパスワードを入力して Enter キーを押しましょう。\n(入力したパスワードは目視で確認ができないため、誤入力に気をつけましょう。)\n無事コマンドを完了できたら、GitHub上でアップロードされたファイルを確認してみましょう。\n リモートリポジトリから最新の履歴を取得する 先ほどは git push コマンドでリモートリポジトリに変更内容を反映いたしました。\nリモートリポジトリが更新されると、他のメンバーはリモートリポジトリから最新のソースコードをダウンロードすることになります。\n(もちろん、他のメンバーがリモートリポジトリを更新したら、あなたも最新のソースコードをダウンロードすることになります。) リモートリポジトリからソースコードをダウンロードする場合は、git pull コマンドを実行します。\ngit pull [リモートリポジトリの名前] [リモートリポジトリのブランチ名] DEMO\n今回はリモートリポジトリ上に main ブランチしかないため、以下のコマンドを実行しましょう。\nただ今回はローカルリポジトリの内容をアップロードしたばかりのため、git pull コマンドを実行してもローカルリポジトリに変化はありません。\ngit pull origin main git pull コマンドを実行することでローカルリポジトリが変わる内容は、応用編で登場しますので楽しみにしてください！\n",
    "description": "",
    "tags": null,
    "title": "Git の基本コマンド",
    "uri": "/git-education/basics/git-command-basics/"
  },
  {
    "content": "Chapter 3 実践編 Git でトラブルが発生した際に解消する知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "実践編",
    "uri": "/git-education/practical/"
  },
  {
    "content": "これで Git の実践編は終了です。\n実際のプロジェクトでも Git でのトラブルは度々起こると思われます。\nしかし、「壊してしまった。。。」となっても元に戻せるのが Git の良いところです。\nトラブルの原因を冷静に見極めて、正しい対処するように心がけましょう！\n",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/practical/summary/"
  },
  {
    "content": "マージとは さきほどはブランチを活用することで他のブランチに影響を与えることなく作業をすることができるとお伝えしました。\nしかし、作成したブランチはあくまで開発用ブランチなので、作業が完了したら納品物となる master ブランチにその変更内容を反映させる必要があります。 このようにあるブランチに他のブランチの変更内容を反映させる作業をマージ（統合）といいます。 マージは git merge コマンドで行うことできますが、変更履歴を更新したいブランチで実行する ことに注意してください。\ngit merge コマンドの後ろに変更内容を取得したいブランチ名を指定します。\ngit merge [変更内容を取得したいブランチ名] マージをしてみよう 今回は master ブランチに develop ブランチの変更内容を反映させてみましょう。\nまずは git branch コマンドを実行して、master ブランチが作業ブランチになっていることを確認しましょう。\n※ 今回は、変更履歴を更新したいブランチ = master ブランチです。\n develop * master 続いて以下の git merge コマンドを実行します。変更内容を取得したいブランチ名は develop を指定しましょう。\ngit merge develop 以下のようなメッセージが表示されればマージは成功です！\nUpdating 5db36ee..1be05c7 Fast-forward sample.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) それでは、マージ後の master ブランチの内容を確認してみましょう。\nまずは cat コマンドで sample.txt の中身を確認してみましょう。\n以下のように develop ブランチの内容に変わっていることが確認できます。\nHELLO 続いて、git log コマンドでコミットログを確認しましょう。\nmaster ブランチのコミットログに対して、develop ブランチでコミットログが追加されていることが 確認できます。\ncommit 1be05c74b8ae9ce1f8b1a09510b1367c88e1100e (HEAD -\u003e master, develop) Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 11:21:55 2022 +0900 develop commit commit 5db36ee820d446e27838869e79cbae3526f71a8f Author: a-nakamura1015 \u003ca-nakamura@esm.co.jp\u003e Date: Fri Mar 11 10:25:56 2022 +0900 first commit なお、マージ後もリポジトリ内には作業ブランチは残ります。\nそのため、マージ後に git checkout コマンドを実行することで同じ作業ブランチで作業を続けることができます。\nしかし、マージするとたいていの作業ブランチは不要になり、リポジトリ内に不要な作業ブランチが溜まっていくことになります。 このようなときは不要なブランチを削除するようにしましょう。 git branch コマンドのオプション（-d）を使用することでブランチを削除することができます。\ngit branch -d [削除したいブランチ名] 今回は develop ブランチを削除してみましょう。\ngit branch -d develop Deleted branch develop (was 1be05c7). 本当に develop ブランチを削除できているかを git branch コマンドで確認してみましょう。\n以下のように develop ブランチが表示されなければ成功です！\n* master このようにして作業用のブランチでの変更内容を他のブランチに反映させることができます。\nここではローカルリポジトリ内でのマージを行いましたが、実際の開発では以下のようなワークフローになります。\n リモートリポジトリの master ブランチから最新のソースを取得する。（git pull origin master） ローカルリポジトリで作業用ブランチを作成して、切り替える。（git branch XXX、git checkout XXX） 作業用ブランチでファイルを編集する。（git add、git commit） リモートリポジトリに作業用ブランチを作成して、アップロードする。（git push origin XXX） リモートリポジトリの作業用ブランチの内容を、リモートリポジトリの master ブランチにマージする。  最後の「リモートリポジトリの作業用ブランチの内容を、リモートリポジトリの master ブランチにマージする。」は、\nローカルリポジトリではなくリモートリポジトリで行うことができます。\nこれを次の GitHub のプルリクエスト機能 でご紹介します。\n",
    "description": "",
    "tags": null,
    "title": "Git のマージ機能",
    "uri": "/git-education/advanced/merge/"
  },
  {
    "content": "GitHub とは ソフトウェア開発のプラットフォームであり、ソースコードを共有するためのホスティングサービス（サーバーの領域を貸し出すサービス）です。\n先述したリモートリポジトリはこのサービスが提供してくれます。\nGitHub のサーバー上にソースコードを格納することで、チームメンバーとソースコードを共有してコードレビューを行ったり、プロジェクトの管理を行ったりすることができます。\n使用用途も様々で、チームメンバーのみがアクセスできるようにすることもできれば、オープンソースとして提供するために世界中のエンジニアにアクセスしてもらえるようにすることもできます。\n名称に Git が含まれている通り、GitHub のバージョン管理システムには Git が使用されています。\nGitHub を始めてみよう GitHub アカウントを作成しよう GitHubを利用するためにはアカウントを作成する必要があります。\n以下の手順に沿って GitHub アカウントを作成しましょう。\n注意：GitHub アカウントを作成するにはメールアカウントが必要になります。\n GitHub の公式サイトにアクセスしましょう。\nhttps://github.com/ 画面右上の Sign up をクリックしましょう。  メールアドレスを入力後、Continue ボタンをクリックしましょう。  パスワードを入力後、Continue ボタンをクリックしましょう。\n※パスワードは任意の内容でOKです！  ユーザーネームを入力後、Continue ボタンをクリックしましょう。  入力したメールアドレス宛に GitHub から認証コードが送られます。\n届いた認証コードを画面に入力しましょう。\n ここからは個人設定となりますが、必須事項ではないので割愛します。\n画面下部の Skip personnnaization をクリックしましょう。\n 以下の画面が表示されればアカウントの作成は完了です！   リモートリポジトリを作成しよう GitHub アカウントがあれば GitHub 上にリモートリポジトリを作成することができます。\n次の手順に沿って作成してみましょう。\n GitHubにログイン後、Create repository ボタンをクリックしましょう。  以下の画面が表示されましたら、以下の手順でリモートリポジトリを作成しましょう。  リポジトリの名前を設定しましょう。今回は tutorial としましょう。 他のユーザーがリポジトリにアクセスできないように非公開にしましょう。\nPublic を選択すると世界中の GitHub ユーザーがアクセスすることができます。\nPrivate を選択するとリポジトリを作成したアカウントのみがアクセスすることができます。    3. 以下の画面が表示されればリモートリポジトリの作成は完了です！ Point: チームメンバーのみにリモートリポジトリを共有したい場合\nPrivate を選択することで他の GitHub ユーザーはアクセスできなくなりますが、チームメンバーにはアクセスできるようにしたいですよね。\nこのようなときは GitHub のリポジトリへ招待する機能を使いましょう。\n 招待したいリモートリポジトリの画面で Setting を選択しましょう。 Settings 画面の左側に表示されているメニューから Collaborators を選択しましょう。 Add people ボタンをクリックしましょう。 入力欄に GitHub のユーザーネーム（またはメールアドレス）を入力して、招待したいユーザーを選択しましょう。  ファイルをアップロードできるようにしよう GitHub上にリモートリポジトリを用意できましたら、次はファイルをアップロードができるようにしましょう。\nGitHub にファイルをアップロードするための通信手段として、HTTPSとSSHの2種類から選ぶことができます。 HTTPSはデータをそのまま送っているのに対し、SSHは暗号化した上で送るためセキュリティの観点からSSHで通信を行うことを推奨します。\nまた、HTTPSとSSHとではそれぞれ設定の手順が異なりますので注意しましょう。\nHTTPS通信の場合\nHTTPS通信でファイルをアップロードするにはアクセストークンが必要になります。\nこのアクセストークンは GitHub の設定画面で発行することができます。 次の手順に沿って作成してみましょう。\n 画面右上のアイコンをクリックしてしてメニューを表示します。 メニュー内の「Settings」を選択します。\n 「Settings」画面のメニュー内の「Developer settings」を選択する。  「Developer settings」画面のメニュー内の「Personal accesstoken」を選択する。  「Personal accesstoken」画面内の「Generate new token」ボタンをクリックします。  Note に任意の文字列を入力し、画面最下部にある「Generate token」ボタンをクリックします。  発行されたアクセストークンをコピーしましょう。  ファイルをプッシュする際にコピーしたアクセストークンをペーストして実行しましょう。  SSH通信の場合\nSSH（Secure SHell）通信は送信しているデータを暗号化していることが特徴です。\nクライアントマシン（例えば、皆さんのPC）で秘密鍵と公開鍵を生成し、公開鍵を送信先の GitHub に設定することでSSH通信を行うことができます。\nそして、GitHub 側は設定したアカウントと公開鍵を紐づけて管理することになります。 次の手順に沿って作成しましょう。\n  秘密鍵と公開鍵を格納するフォルダに移動しましょう。 ホームディレクトリの直下にある.sshフォルダの直下に秘密鍵と公開鍵を置くことができます。\n以下のコマンドで.sshフォルダに移動しましょう。\ncd ~/.ssh .sshフォルダがない場合は以下のコマンドで削除した上で移動しましょう。\nmkdir ~/.ssh   秘密鍵と公開鍵を生成しましょう。 以下のコマンドで秘密鍵と公開鍵を生成することができます。\nssh-keygen -t rsa コマンドを実行すると以下の３点を確認されます。 ①秘密鍵と公開鍵のファイルの名前 ②秘密鍵と公開鍵のパスフレーズ ③秘密鍵と公開鍵のパスフレーズの再確認\n以下のメッセージが表示されますが、必須の設定ではないためEnterキーをクリックすることでスキップすることができます。\nGenerating public/private rsa key pair. Enter file in which to save the key (/Users/(username)/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again:   秘密鍵と公開鍵が生成されたことを確認しましょう。 lsコマンドで以下の２ファイルが生成されていることを確認しましょう。\n id_rsa id_rsa.pub  生成されたファイルのうち、id_rsa が秘密鍵、id_rsa.pub が公開鍵になります。\n公開鍵である id_rsa.pub の内容を GitHub に設定することになります。\n  公開鍵を GitHub に設定しましょう。\n 「Settings」画面のメニュー内の「SSH and GPG keys」を選択しましょう。 「SSH and GPG keys」画面内の「New SSH key」ボタンをクリックしましょう。 コマンドで公開鍵の内容をコピーしましょう。\n【Macの場合のコマンド】 pbcopy \u003c ~/.ssh/id_rsa.pub 【Windowsの場合のコマンド】 clip \u003c ~/.ssh/id_rsa.pub   で表示した画面の Title に秘密鍵のファイル名を入力し、Key に 3. でコピーした内容を貼り付けましょう。   「Add SSH key」ボタンをクリックしましょう。    SSH接続ができているかを確認しましょう。 次のコマンドでSSH接続ができているかを確認することができます。\n  ssh -T git@github.com 以下のメッセージが表示されれば接続は成功しています。\nHi (account名)! You've successfully authenticated, but GitHub does not provide shell access. 接続がうまくいかなかった場合は手順通りに行えていないところがある可能性があるので、もう一度見直してみましょう。\n",
    "description": "",
    "tags": null,
    "title": "GitHub の基本",
    "uri": "/git-education/basics/github-basics/"
  },
  {
    "content": "プルリクエストとは ここまでの学習内容をマスターできていれば、ローカルリポジトリで変更した内容をリモートリポジトリにアップロードすることができるようになっているはずです。\nあとは変更内容をリモートリポジトリの master ブランチにマージするのみです。\nしかし、ここで安易にリモートリポジトリの master ブランチにマージするのは危険です。\nなぜなら、リモートリポジトリの master ブランチはチームで共有しているため、勝手に更新すると困ってしまうメンバーが出てきてしまうかもしれません。\nまた、そもそもローカルリポジトリで行った変更が正しくなかったり、対応が足りていなかったりする可能性もあります。\nこのようなときは プルリクエスト という GitHub の機能を利用します。\nこの機能を使用すると、簡単に他のメンバーに変更内容のレビューを依頼することができます。\n他のメンバーにレビューしてもらうことで事前にトラブルやリスクを回避することができるのです。\nメモ： GitHub 以外のリモートリポジトリのサービスにもプルリクエストと同様の機能がありますが、\n名称が異なる場合があります。\n例えば、GitLab の場合は同様の機能を「マージリクエスト」と呼称されています。\nプルリクエストを作ってみよう 今回は以下の手順に沿って進めていき、最終的にはプルリクエストを作ってみましょう。\n(1) ローカルリポジトリの develop ブランチで sample.txt の内容を「APPLE」に上書きします。\n(2) リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\n(3) develop ブランチでの変更を master ブランチにマージする内容のプルリクエストを作成します。\n (1) ローカルリポジトリの develop ブランチで sample.txt の内容を「APPLE」に上書きします。\n まずはローカルリポジトリに作業用ブランチである develop ブランチを作成しましょう。\n先程は git branch [ブランチ名] と git checkout [ブランチ名]を実行しましたが、\ngit checkout コマンドのオプション（-b）の後にブランチ名を指定すると、\nこの２つの処理を1つのコマンドで行うことができます。\ngit checkout -b [ブランチ名] 今回は develop ブランチを作成して、同ブランチを作業ブランチにしたいため以下のコマンドを実行します。\ngit checkout -b develop 作業ブランチに切り替わったので、以下のコマンドを実行して sample.txt の内容を「APPLE」となるように上書きしましょう。\necho APPLE \u003e sample.txt 作業が終わったので、以下のコマンドを実行して変更内容をコミットしましょう。\ngit add sample.txt git commit -m \"updated sample.txt\"  (2) リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\n ローカルリポジトリの変更内容をリモートリポジトリに反映しましょう。\n以下のコマンドを実行して、リモートリポジトリに develop ブランチを作成し、変更内容をアップロードします。\ngit push origin develop コマンドを実行したのち、GitHub上で編集したファイルを確認してみましょう。\n (3) develop ブランチでの変更を master ブランチにマージする内容のプルリクエストを作成します。\n GitHub の画面の [Pull request] をクリックしましょう。 クリックするとプルリクエストの一覧の画面に切り替わります。\n続いて、画面内の「New pull request」ボタンをクリックしましょう。 クリックするとプルリクエストを作成する画面に切り替わります。\nこの際にマージ先のリモートブランチを指定します。\n今回は develop（リモート）の内容を、master（リモート）にマージします。\nこの画面でファイルの差分を確認することができます。\nここで意図しない修正が見つかった場合はローカルリポジトリで再修正した後、 再度リモートリポジトリにプッシュをしましょう。\n内容に問題がなければ「Create pull request」ボタンをクリックしましょう。 最後に、プルリクエストのタイトルとその内容を記載します。\nまた、リモートリポジトリに招待されているアカウントをレビュワーに 指定することができます。\n今回は事前に他のアカウントを招待していないためレビュワーを指定できませんが、\n実際の開発ではここでレビュワーを指定することができます。\nもう一度内容を確認して問題がなければ、「Create pull request」ボタンをクリックしましょう。\nプルリクエストが作成できれば成功です！ プルリクエストが作成されると、レビュワーにメールで通知されます。 （このメールは GitHub アカウントに紐付いているメールアドレスです。） GitHub の画面の [Pull request] をクリックしましょう。\nクリックするとプルリクエストの一覧の画面に切り替わります。\nすると、先ほど作成したプルリクエストを確認することができます。\n仮にレビュワーが変更内容を承認した場合はチェックマークが表示されます。 今回はレビュワーがいないためレビュワーから承認があったと仮定して、 最後にリモートリポジトリの master ブランチにマージしてみましょう。\nまずは「Merge pull request」ボタンをクリックします。\nすると、「Confirm merge」ボタンが表示されます。\nこのボタンをクリックすると 、リモートリポジトリの master ブランチと develop ブランチをマージし、\nマージをしたという内容のコミットログを生成されます。\n「Confirm merge」ボタンをクリックするとマージが完了しますが、その後「Delete branch」ボタンが表示されます。 このボタンをクリックするとリモートリポジトリの作業ブランチ（develop ブランチ）が削除されます。\n同じ作業ブランチを残しておきたい場合はクリックする必要はないですが、不要な場合はこのボタンをクリックして削除しましょう。 これでリモートリポジトリの master ブランチに変更内容が反映されました。\n本当に反映できているかを以下の手順で確認をしてみましょう。\n(1) ローカルリポジトリの作業ブランチを master ブランチに切り替えます。 (2) リモートリポジトリの master ブランチから最新のファイルをダウンロードします。\n (1) ローカルリポジトリの作業ブランチを master ブランチに切り替えます。\n 以下のコマンドを実行して作業ブランチを master ブランチにしましょう。\ngit checkout master  (2) リモートリポジトリの master ブランチから最新のファイルをダウンロードします。 以下のコマンドを実行して、リモートリポジトリの master ブランチから最新のファイルをダウンロードしましょう。\n git pull origin master コマンド実行後に cat コマンドで sample.txt の中身を確認してみましょう。\nファイルの内容が「APPLE」になっていれば成功です！¥\n",
    "description": "",
    "tags": null,
    "title": "GitHub のプルリクエスト機能",
    "uri": "/git-education/advanced/pull-request/"
  },
  {
    "content": "以上が基本編の内容となります。基本編では Git の基礎的な知識やコマンドをおさえました。\nこれで一人で Git にファイルの変更履歴を残しながら開発を進めることができるようになったはずです。\nしかし、チーム開発では基本編の知識だけでは不足しています。\n応用編ではチーム開発で必要となる知識とコマンドをおさえていきましょう。\n",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/basics/summary/"
  },
  {
    "content": "応用編では Git でチーム開発を行う方法について学習しました。\nGit の開発フローを理解できれば実際に活用するのは難しくありません。\n実際の開発で使用する Git のコマンドはさほど多くはありません。\nそれぞれのコマンドの意味を一つずつ確実に理解をしていきましょう。\nこの度紹介した開発フローとコマンドで事足りますが、\nGit を活用してもいろいろなトラブルが発生します。\n例えば、複数人が同じファイルを同じ箇所を同時に変更されたり、\n一度 Git にコミットした内容を取り消したいなどがあります。\nこのようなトラブルが起きたときはどのように解消したらよいかを 実践編 でお伝えします。\n",
    "description": "",
    "tags": null,
    "title": "まとめ",
    "uri": "/git-education/advanced/summary/"
  },
  {
    "content": "Git X EDU 本コンテンツはバージョン管理システムである Git を習得するためのコンテンツです。\n現在の開発現場では Git の操作は必須のスキルです。\n本コンテンツを終了する頃には Git を使用してファイルの変更履歴を遡ったり、\nチームメンバーとお互いにコードレビューができるようになっているでしょう。\nペルソナ Git を初めて学ぶ、もしくは Git を触り始めて日が浅い方が本コンテンツの受講者と想定しています。\n前提条件  基本的な linux コマンドを習得していること  準備物  Mac の場合  ターミナル   Windows の場合  GitBash    linux コマンドを実行できるコンソールアプリであれば、上記のアプリ以外でも問題ありません。\nカリキュラム 本コンテンツは「基礎編」、「応用編」、「実践編」の３つで構成されています。\n「基礎編」→「応用編」→「実践編」の順で進めていきましょう。\n基礎編 Git でバージョン管理をする上で最低限必要となる知識を身につけます。\n応用編 Git でチーム開発をする上で必要となる知識を身につけます。\n実践編 Git でトラブルが発生した際に解消する知識を身につけます。\n",
    "description": "",
    "tags": null,
    "title": "Git X EDU",
    "uri": "/git-education/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/git-education/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/git-education/tags/"
  }
]
